#!/bin/bash
#################################################################################
# Pulls the configurations
################################################################################
pull_config(){
    # echo -n "Pulling philconfig configurations : "
    pushd $CONFIG_DIR > /dev/null
    git pull > /dev/null 2>&1
    pull_success=$?
    popd > /dev/null
    if [[ $pull_success != 0 ]]; then
        echo "!! Could not pull pull philconfig !!"
    fi
}

################################################################################
# Variants on the cd function:
# - cdf : cd to the first result of a find command
# - cdl : cd to the target directory of a link
# - cdw : cd to the directory found using which
################################################################################
cdf(){
    result="$(find . -name "$1" -print -quit)"
    if [[ -d "$result" ]] ; then
        cd $result
        echo $(pwd) 1>&2
    elif [[ -f "$result" ]] ; then
        cd "$(dirname "$result")"
        echo $(pwd) 1>&2
    elif [[ $result == "" ]]; then
        echo "cdf: nothing found matching $1" 1>&2
    else
        echo "result $result could not be cd'd into" 1>&2
    fi
}

path_is_relative() {
    if ! [[ "$1" == /* ]] ; then
        return 0
    else
        return 1
    fi
}

cdl () {
    link=$1

    target=$(readlink $link)
    link_dir=$(dirname $link)

    if path_is_relative $target ; then
        target=$link_dir/$target
    fi

    if [ -d $target ] ; then
        dir=$target
    else
        dir=$(dirname $target)
    fi

    cd $dir
}

cdw (){
    target=$(which $1)
    cd $(dirname $target)
}

################################################################################
# Git push all branches to repository
################################################################################
pushall(){
    # Todo: upgrade this to prompt for each branch (asking y/n) whether we want
    # to push it.
    if [[ $1 == "" ]]; then
        remote=origin
    else
        remote=$1
    fi
    for b in $(git branch | tr '*' ' '); do
        echo -n "Push branch $b (y/n)? " 1>&2
        read answer
        if [[ "$answer" == y ]] ; then
            git push $remote $b;
        fi
    done
}


################################################################################
# Connects over ssh to school computer of my choice
################################################################################
ssh_school() {
    if [[ $1 == "" ]]; then
        computer="l4712-01"
    else
        computer=$1
    fi
    ssh $computer.info.polymtl.ca -l phcarb -Y
}

################################################################################
# Uses find to go to a directory that is not in the PWD nor on CDPATH
################################################################################
p_valgrind(){
    flags=$3
    cmd=$1
    if [ "$2" != "" ] ; then
        target=$2
    else
        target=~/valgrind.lst
    fi
    valgrind $flags $cmd > $target 2>&1
}

################################################################################
# Remove accents from a file in-place (note, only the accented characters that
# would show up in the French language).
################################################################################
accents="âàäêèëéîïôöûùüÿçÂÀÄÊÈËÉÎÏÔÖÛÙÜŸÇ¨"
no_accents="aaaeeeeiioouuuycAAAEEEEIIOOUUUYC "
fremove-accents () {
file=$1
if [ -z $file ] ; then
    echo "fremove-accents error: no file specified"
    return
fi

if ! [ -e $file -o -L $file ] ; then
    echo "fremove-accents error: file $file doesn't exist"
    return
fi

cp $file $file.bak
tr "$accents" "$no_accents" < $file > $file.removed_accents
}

git_pwd() {
    if [[ $(git rev-parse --is-inside-work-tree 2>/dev/null) == true ]] ; then
        repo_dir=$(git rev-parse --show-toplevel 2>/dev/null)
        outer=$(basename $repo_dir)
        inner=$(git rev-parse --show-prefix 2>/dev/null)
        echo "${outer}/${inner}"
    else
        echo '\w'
    fi
}

################################################################################
# Functions
################################################################################
at_cmc() {
    local username=$(whoami)
    [ $username = afsmpca ] || [ $username = afsmphc ]
}
cmc_network(){
    if [ -e ~/.network_is_ec ] ; then
        echo "ec"
    else
        echo "science"
    fi
}

at_poly() {
    if [ $(whoami) = phcarb ] ; then
        true
    else
        false
    fi
}

################################################################################
# Vim with special arguments
################################################################################
vimw() {
    filepath=$(which $1); shift
    vim $filepath $@
}

longest_common_prefix() {
    # ref https://stackoverflow.com/a/32116308/5795941
    lines="$1"
    prefix="$(echo "$lines" | \grep -zoP '^(.*)(?=.*?\n\1)')"
    echo "$prefix" | tail -1
}

common_dir() {
    lines=$1
    common_text="$(longest_common_prefix "$lines")"
    if [ -d $common_text ] ; then
        common_dir=$common_text
    else
        common_dir=$(dirname $common_text)
    fi
    echo $common_dir
}

vimf() {
    query=$1; shift
    results="$(find . -name "$query")"

    dir=$(common_dir "$results")

    # Go into found directory
    if pushd $dir 2>/dev/null ; then

        # Re-do query from new directory
        new_results="$(find . -name "$query")"

        # Report results
        echo -e "directory=$dir \nfiles="
        echo "$new_results" | sed 's/^/   /g'
        echo "Press any key to continue"
        read

        # Launch vim with these results
        cmd="vim $new_results $@"
        eval $(echo $cmd | tr '\n' ' ')
        popd 2>/dev/null
    else
        echo "Could not cd into $common_dir"
    fi
}

vimff() {
   vim $(fuzzyfind "$1")
}

################################################################################
# Edit philconfig
################################################################################
function profile() {
    echo "Edit philconfig"
    old_pwd=$PWD
    cd $CONFIG_DIR
    files=""
    for arg in $@ ; do
        files="$files $(find ./* -name "*$arg*" | tr '\n' ' ')"
    done
    eval vim $files $rcfile $(find ./* -type f)
    source $rcfile
    cd $old_pwd
}

fuzzyfind() {
    search_string="$(echo $1 | sed 's/\(.\)/\*\1/g')*"
    find ./* -name "$search_string"
}
normal_mode() {
   unset CDPATH
	set +o vi
   touch ~/.normal_mode
   exec bash
}

phil_mode(){
   rm ~/.normal_mode
   if which zsh 2>/dev/null ; then
      exec zsh
   else
      exec bash
   fi
}

gitignore() {
   # The name giti comes from tab completion:
   # If you're in your repo's root, you have to type up to the second i for the
   # comleter to complete with .gitignore because of the .git directory.
   # Therefore giti has become strongly associated in my mind with the gitignore
   # file.
   local giti=$(git root)/.gitignore
   if [ -z $1 ] ; then
      vim $giti
   else
      echo $1 >> $giti
   fi
   git add $giti
   git diff --staged $giti
}

pycharm(){
   nohup pycharm $@ >/dev/null 2>&1 &
}

org(){
    emacs -nw ~/Documents/Notes/Notes_BUCKET/Notes_MAIN.org
}

org-new(){
    emacs -nw ~/Documents/Notes/Notes_BUCKET/__NEW__.org
}

echolist(){
    echo $1 | tr ':' '\n'
}

cmc_check_git(){
    local gv=$(git --version | cut -d ' ' -f 3)
    local major=$(cut -d '.' -f 1 <<< $gv)
    local minor=$(cut -d '.' -f 2 <<< $gv)

    if [ $major -lt 2 ] ; then
        git_stoneage_message $gv
    elif [ $major -eq 2 ] && [ $minor -lt 13 ] ; then
        git_unsupported_message $gv
    fi
}

git_stoneage_message(){
    local gv=$1
    echo "$(tput setab 1)$(tput setaf 15)You are using a version of git ($gv) from the stone age$(tput sgr 0)"
    echo "You can setup links to things in $(tput setaf 2)/ssm/net/cmoi/apps/git/...$(tput sgr 0) to put in $(tput setaf 2)~/.local/bin$(tput sgr 0)"
    echo "make sure you do the same for gitk"
}

git_unsupported_message(){
    local gv=$1
    echo "$(tput setab 11)You are using a version of git ($gv) that is no longer supported$(tput sgr 0)"
    echo "Maybe someday, we'll have a version of git that is still supported"
}
