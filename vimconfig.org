#+TITLE: Vimrc file
#+PROPERTY: header-args:vimrc :tangle vimrc :results none
#+PROPERTY: header-args:filetype :tangle filetype.vim :results none
#+OPTIONS: toc:2

* Shell command to tangle

To tangle from the shell, use this command:
#+begin_src sh
emacs --batch -l org --eval "(setq org-src-preserve-indentation t)" FILE -f org-babel-tangle
#+end_src

Note where the =FILE= appears in the command.

It seems that it must appear before the =-f org-babel-tangle= argument.

The manual =man emacs= says this about =-f=, =-l=, =-e, --eval=:

#+begin_quote
The following options are Lisp-oriented (these options are processed in the
order encountered):
#+end_quote

* Header


#+begin_src vimrc
" This file was generated from vimconfig.org by using org-babel-tangle.
" That file is 'tangled' to make this vimrc file which should be pointed to
" by a link '~/.vimrc -> $this_file'
#+end_src

* Fundamental
** Be iMproved

#+begin_src vimrc
set nocompatible              " be iMproved, required
filetype plugin indent on
#+end_src

** Remember position in file

This line can be found commented in the system vimrc file : =/etc/vim/vimrc=.
#+begin_src vimrc
autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal!  g'\"" | endif
#+end_src
I left out the =if has("autocmd")= because I have yet to encounter a version of
vim that does not have it.

*** Exception for commit messages

Git reuses =.git/COMMIT_EDITMSG= for when editing commit messages with the
editor.  In that context we always want the cursor to start on the first
line.  We do the same thing for the =git-rebase-todo= file that is used for
interactive rebases.

#+begin_src vimrc
autocmd BufReadPost COMMIT_EDITMSG,git-rebase-todo :0
#+end_src

** Indentation

We use listchars to show unwanted whitespace characters: tabs are shown as =»~=
when space is the preferred indentation and leading spaces are shown as =»= in
=go= and =make= where real =\t= characters are the preferred indentation method.

*** General

#+begin_src vimrc
set autoindent
set list
#+end_src

*** 4 spaces for everything

Allways use 4 spaces, if a file does contain real =\t= characters, display them
4 spaces wide

#+begin_src vimrc
set tabstop=4       " Display width of \t character
set shiftwidth=4    " Indents will have a width of 4.
set softtabstop=4   " Sets the number of columns for a TAB.
set expandtab       " Expand TABs to spaces.
#+end_src

Display unwanted whitespace characters by setting =listchars=.

#+begin_src vimrc
set listchars=tab:»~,extends:›,precedes:‹,nbsp:·,trail:·
#+end_src

*** Tabs for go and make

Display tabs 4 spaces wide and don't convert to spaces.

#+begin_src vimrc
autocmd FileType make,go setlocal tabstop=8 shiftwidth=8 softtabstop=0 noexpandtab
#+end_src

Change =listchars= to show indentation with spaces and display tabs normally.

The system vim doesn't have the =lead= part for =listchars= so we have to use
an if.  I don't know when it was introduced but I know vim 9.0 has it and vim
8.2 doesn't.

If we don't have vim 9, we show a dot for all spaces which is really not that
bad.

#+begin_src vimrc
if version >= 900
    autocmd FileType make,go setlocal listchars=tab:\ \ ,lead:·,trail:·,precedes:←,extends:→
else
    autocmd FileType make,go setlocal listchars=tab:\ \ ,space:·,trail:·,precedes:←,extends:→
endif
#+end_src

**** Alternative for leading whitespace in vim < 9

This [[https://stackoverflow.com/a/40498439][solution by rodrigo]] is an
alternative that I decided not to use but I'm documenting my use of it here
since I had to figure out some things to make it work.

Another solution is to highlight spaces at the beginning of the line.

We create a highlight group =WhiteSpaceBol=

#+begin_src vimrc :tangle no
highlight WhiteSpaceBol ctermbg=red
#+end_src

and have it match white space at the beginning of the line for Makefiles and
Go files.

#+begin_src vimrc :tangle no
autocmd FileType make,go match WhiteSpaceBol /^ \+/
#+end_src

For this to work, the definition of the highlight group needs to come after
the loading of the colorscheme in the =~/.vimrc= file and the =match= needs
to come after the highlight group has been defined.  Because it's in an
=autocmd=, it can come before in the =.vimrc= file.

If I wanted to use this, I would need to move the =highlight WhiteSpaceBol
ctermbg=red= somewhere else in the file.

However, I decided that I didn't like it that much and having =space:·= in
listchars works just fine.


*** Two spaces for yaml

#+begin_src vimrc
autocmd FileType yaml setlocal tabstop=2 shiftwidth=2 softtabstop=2 expandtab
#+end_src

*** Use AnsiEsc for =*.out= files

#+begin_src vimrc
autocmd BufRead *.out,*.log :AnsiEsc
autocmd BufRead *.out,*.log setlocal nowrap
#+end_src

** Wrapping

*** Hard Wrapping
#+begin_src vimrc
set textwidth=0
#+end_src
See =:help textwidth= setting =textwidth= to a non-zero value activates
automatic hard wrapping while inserting.
#+begin_src vimrc
" This doesn't work but I tried it with autocmd filetype and it seemed to
" work
" au BufRead,BufNewFile *.md setlocal textwidth=80
" au BufRead,BufNewFile *.org setlocal textwidth=80
" au BufRead,BufNewFile *.txt setlocal textwidth=80
#+end_src

*** Visual wrapping

**** Configure visual wrapping

#+begin_src vimrc
set wrap
set wrapmargin=0
set colorcolumn=80
#+end_src

**** Set j,k to move up and down visual lines

This makes =j,k= move up and down display lines instead of moving by physical
lines (i.e. defined by ='\n'=) in normal and visual modes.

#+begin_src vimrc
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk
#+end_src

** MISC

#+begin_src vimrc
syntax on
set scrolloff=5
set hlsearch
set number
set showcmd " Display incomplete commands at the right
set backspace=indent,eol,start " Usual backspace behavior
set encoding=utf-8
#+end_src

* Additional
** Color

#+begin_src vimrc
set t_Co=256 " Apparently this has to be set before setting the color scheme
colorscheme molokai " Requires https://github.com/tomasr/molokai
#+end_src

** Plugins
*** Markdown nested folding

Plugin : https://github.com/masukomi/vim-markdown-folding

#+begin_src vimrc
autocmd FileType markdown setlocal foldexpr=NestedMarkdownFolds()
#+end_src

*** Org

Plugins :
- https://github.com/jceb/vim-orgmode
- https://github.com/tpope/vim-speeddating

Org todo keywords
#+begin_src vimrc
let g:org_todo_keywords=['TODO', 'GTD-IN', 'GTD-ACTION', 'GTD-PROJECT', 'GTD-NEXT-ACTION', 'GTD-WAITING', 'GTD-SOMEDAY-MAYBE', 'FEEDBACK', 'VERIFY', '|', 'DONE', 'GTD-DONE', 'GTD-REFERENCE', 'GTD-DELEGATED']
#+end_src

Path to elisp backend
#+begin_src vimrc
let g:org_export_emacs="~/.local/bin/emacs"
#+end_src

** Status line
*** Always show status line

2 means always

#+begin_src vimrc
set laststatus=2
#+end_src

*** New Powerline
**** Install instructions

These are the official instructions but this is not what I do.

https://powerline.readthedocs.io/en/latest/installation/osx.html#python-package

**** Using powerline

I use powerline with vim8's native plugin handling.

I put a link pointing to =$repo/powerline/bindings/vim= inside the
=~/.vim/pack/*/start=.

Make sure =laststatus=2= makes it always displayed.

**** Important note about macos

Adding powerline made vim hang and fail to start on my mac.  I figured out that
changing to a version of vim that has python3 support fixed my problem.

I did
#+begin_src shell
brew install --cask macvim
#+end_src
and made sure that this version of vim is the one being used.

*** Old powerline

Just added the submodule https//github.com/lokaltog/vim-powerline.  No need
to do anything else than make sure the =laststatus= is set to 2 (always).

Edit: I removed it but I am leaving this section here.  The new powerline made
my vim not start until I replaced it with macvim installed from homebrew.

The lokaltog one however doesn't need anything like that.

As far as I know, the problem only happens on mac and on the various linux
computers I have tried, the new powerline has not been an issue.

** Keys

*** Leaving insert mode

#+begin_src vimrc
inoremap jk <ESC>
#+end_src

**** Cursor position after leaving insert mode

99.99% of the time, I ended up pressing =l= after pressing =<ESC>= to leave
insert mode.

[[https://vim.fandom.com/wiki/Prevent_escape_from_moving_the_cursor_one_character_to_the_left#Programmatic_Alternative][This Vim Fandom answer]]
gives the solution used below and also tells you that if you want this this
behavior, then you dont care about consistency.  Hey Vim Fandom, you know
what's very consistent?  The fact that I always press =l= after leaving
insert mode!

#+begin_src vimrc
let CursorColumnI = 0 "the cursor column position in INSERT
autocmd InsertEnter * let CursorColumnI = col('.')
autocmd CursorMovedI * let CursorColumnI = col('.')
autocmd InsertLeave * if col('.') != CursorColumnI | call cursor(0, col('.')+1) | endif
#+end_src

Because of the nature of 'ESC' and the fact that terminals implement things
like function keys using =<ESC>[15~=, Vim waits a little while after <ESC>
has been received to see if something like =[15~= follows.

[[https://superuser.com/questions/1579208/delay-after-hitting-escape]]
[[https://vi.stackexchange.com/questions/16148/slow-vim-escape-from-insert-mode]]

This delay can be completely eliminated by telling vim that you will never
use such keys.  In that case, =ESC= will always mean that the user pressed
that key on the keyboard and there is no need for the delay.

#+begin_src vimrc
" set noesckeys
#+end_src

However I noticed that the arrow keys are implemented as an escape sequence.
Although I never use them, sometimes, I do them by mistake and the behavior
with =set noesckeys= is much more annoying than my =:echoerr "your mind is
weak"= things.

Instead, we can set =ttimeoutlen= to a very small value like 50ms and this is
short enough that we cannot notice it, but longer than the time between
successive keycodes sent by the terminal to communicate an arrow key.

#+begin_src vimrc
set timeoutlen=500 ttimeoutlen=50
#+end_src


*** Cursor position after paste

Normally, the cursor ends on the last char of the pasted text but most of the
time, you want it after the pasted text:

#+begin_src vimrc
nnoremap p pl
nnoremap P Pl
#+end_src

*** Scrolling

Up down move the cursor in one direction and scrolls the view in the other.
This has the effect that the cursor stays in the same place on the screen
which is a good behavior for scrolling.
#+begin_src vimrc
nnoremap <Up> <C-y>k
nnoremap <Down> <C-e>j
#+end_src

*** Make arrows print quotes from The Shadow (1994) with Alec Baldwin
#+begin_src vimrc
nnoremap <Left> <ESC>:echoerr "Your mind is weak."<CR>
nnoremap <Right> <ESC>:echoerr "Your mind is weak."<CR>

inoremap <Up> <C-O>:echoerr "Join me or die"<CR>
inoremap <Down> <C-O>:echoerr "The clouded mind sees nothing"<CR>
inoremap <Left> <C-O>:echoerr "Your mind is weak."<CR>
inoremap <Right> <C-O>:echoerr "The clouded mind sees nothing"<CR>
#+end_src

** Use system clipboard

Tested on MacOS with Vim 8+

Reference : =:help clipboard=
#+begin_src vimrc
if $SSH_CLIENT == ""
    set clipboard=unnamed
endif
#+end_src

** Display % as . in Fortran

Fortran uses =object%attribute= to get a field of a struct (in Fortran they
don't call it a struct, I think they call it a type).

#+begin_src vimrc
" Funny thing to show '%' as '.' in Fortran files
" autocmd FileType fortran set conceallevel=2
" autocmd FileType fortran call matchadd('Conceal', '%', 10, -1, {'conceal': '.'})
#+end_src

** YouCompleteMe

#+begin_src vimrc
" Technically version > 8.1.2269 but I only encounter either vim 8.0 or vim 9+
" so this is easier
if version >= 900
    " Silent makes it not complain if the package doesn't exits in
    " .vim/pack/*/opt/
    silent! packadd YouCompleteMe
    nnoremap gd :YcmCompleter GoToDefinition<CR>
endif
#+end_src

** Command to justify text

This loads a visual mode command =_j= that will justify a paragraph of text.

The usefulness of this is somewhat questionnable, but it's fun to have I
guess.

Note that the format the format option 't' (=formatoptions+=t=) may make a
difference.  I read somewhere that it was needed but I'm not sure in what
cases.  I don't want to erroeneously think that it is needed so I'm leaving
it in commented.

#+begin_src vimrc
runtime macros/justify.vim
" set formatoptions+=t
#+end_src


* Filetype associations

This section generates the file =filetype.vim=.

#+begin_src filetype
" This file is generated by org-tangle'ing vimconfig.org using the command
" 'emacs --batch -l org --eval "(setq org-src-preserve-indentation t)" vimconfig.org -f org-babel-tangle'
if exists("did_load_filetypes")
  finish
endif
augroup filetypedetect
#+end_src


** Non-standard fortran file extensions

These extensions are used in conjunction with =s.cc= or =s.compile=.  These
wrappers do something different with the files based on the extension.
However these are not know by standard programs.

#+begin_src filetype
    autocmd BufRead,BufNewFile *.ftn,*.ftn90,*.cdk,*.cdk90,*.inc,*.hf set filetype=fortran
#+end_src

** '.dot' file from CMC

The =.dot= extension is used to indicate that the script in question is meant
to be sourced.  The extension is recognized by vim as 'dot graph'.  To
override this:

#+begin_src filetype
    autocmd BufRead,BufNewFile *.dot set filetype=sh
#+end_src

** CMC profile files
#+begin_src filetype
    autocmd BufRead,BufNewFile */.profile.d/interactive/pre    set filetype=sh
    autocmd BufRead,BufNewFile */.profile.d/interactive/post   set filetype=sh
#+end_src
** Package file

Files meant to be sourced by my custom function =p.use= inspired by
François's function =f.use= which basically does
=source ~/.profile.d/interactive/pack/$1=

#+begin_src filetype
    autocmd BufRead,BufNewFile */.profile.d/interactive/pack/* set filetype=sh
#+end_src

** CMC maestro files

When we ask maestro open a listing, it will decompress the stored listing
into a file in some subdirectory of =/tmp/= name the file =masetro_something=
#+begin_src filetype
    autocmd BufRead,BufNewFile *.def,*/.suites/*/*.cfg,/tmp/phc001/*/maestro* set filetype=sh
#+end_src


#+begin_src filetype
augroup END
#+end_src
