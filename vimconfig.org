-*- org-src-preserve-indentation: t -*-
#+TITLE: Vimrc file
#+PROPERTY: header-args:vimrc :tangle vimrc :results none
#+OPTIONS: toc:2

* Header

This just puts a comment header in the generated vimrc file.

#+begin_src vimrc
" This file was generated from vimconfig.org by using org-babel-tangle.
"
"     emacs --batch \
"           --eval "(setq org-src-preserve-indentation t)" \
"           vimconfig.org \
"           -f org-babel-tangle
"
" That file is 'tangled' to make this vimrc file which should be pointed to
" by a link '~/.vimrc -> $this_file'
#+end_src

* Notes

I only discovered this recently and maybe it depends on the version of vim
but if you don't have a =~/.vimrc= but you do have a =~/.vim/vimrc=, vim will
load that.

** Acceptable builtin themes

- desert
- elflord
- evening
- habamax
- industry
- koehler
- lunaperche
- murphy
- pablo
- ron
- slate
- torte

** Setting color of colorcolumn

Some color schemes (not molokai) set a weird color for the ColorColumn, to
set it to something else after loading such a color scheme, use
#+begin_src vimrc :tangle no
hi ColorColumn ctermbg=245
#+end_src

* Fundamental
** Be iMproved

#+begin_src vimrc
set nocompatible              " be iMproved, required
#+end_src

** Remember position in file

This line can be found commented in the system vimrc file : =/etc/vim/vimrc=.
#+begin_src vimrc
autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal!  g'\"" | endif
#+end_src
I left out the =if has("autocmd")= because I have yet to encounter a version of
vim that does not have it.

*** Exception for commit messages

Git reuses =.git/COMMIT_EDITMSG= when editing commit messages with the
editor.  In that context we always want the cursor to start on the first
line.  We do the same thing for the =git-rebase-todo= file that is used for
interactive rebases.

#+begin_src vimrc
autocmd BufReadPost COMMIT_EDITMSG,git-rebase-todo :0
#+end_src

** Indentation

*** General

Set basic autoindent: this will just keep the indent level constant as you
insert new lines.
#+begin_src vimrc
set autoindent
#+end_src

This however gives indentation based on the language such as increasing the
indentation when it should. See =:help filetype=
#+begin_comment
command                         detection       plugin          indent
:filetype on                    on              unchanged       unchanged
:filetype off                   off             unchanged       unchanged
:filetype plugin on             on              on              unchanged
:filetype plugin off            unchanged       off             unchanged
:filetype indent on             on              unchanged       on
:filetype indent off            unchanged       unchanged       off
:filetype plugin indent on      on              on              on
:filetype plugin indent off     unchanged       off             off
#+end_comment
where /detection/ means filetype detection, /plugin/ means loading plugin
files for specific file types, and /indent/ means loading indent files for
specific file types.

#+begin_src vimrc
filetype plugin indent on
#+end_src

*** 4 spaces for everything

Allways use 4 spaces, if a file does contain real =\t= characters, display them
4 spaces wide

#+begin_src vimrc
set tabstop=4       " Display width of \t character
set shiftwidth=4    " Indents will have a width of 4.
set softtabstop=4   " Sets the number of columns for a TAB.
set expandtab       " Expand TABs to spaces.
#+end_src

We use listchars to show unwanted whitespace characters: tabs are shown as =»~=
when space is the preferred indentation and leading spaces are shown as =»= in
=go= and =make= where real =\t= characters are the preferred indentation method.


#+begin_src vimrc
set listchars=tab:»~,extends:›,precedes:‹,nbsp:·,trail:·
set list
#+end_src

*** Two spaces for yaml

#+begin_src vimrc
autocmd FileType yaml setlocal tabstop=2 shiftwidth=2 softtabstop=2 expandtab
#+end_src

*** Use AnsiEsc for =*.out= files

The plugin
[[https://github.com/powerman/vim-plugin-AnsiEsc][Ansi-Esc]]
provides the command =AnsiEsc= that hides ANSI escape codes and colors the file
according to these codes.  For file extensions that are likely to contain such
codes such log files, we call this function on opening the file.

#+begin_src vimrc
autocmd BufRead *.out,*.log :AnsiEsc
autocmd BufRead *.out,*.log setlocal nowrap
#+end_src

** Wrapping

*** Hard Wrapping
#+begin_src vimrc
set textwidth=0
#+end_src
See =:help textwidth= setting =textwidth= to a non-zero value activates
automatic hard wrapping while inserting.
#+begin_src vimrc
" This doesn't work but I tried it with autocmd filetype and it seemed to
" work
" au BufRead,BufNewFile *.md setlocal textwidth=80
" au BufRead,BufNewFile *.org setlocal textwidth=80
" au BufRead,BufNewFile *.txt setlocal textwidth=80
#+end_src

*** Visual wrapping

**** Configure visual wrapping

#+begin_src vimrc
set wrap
set wrapmargin=0
#+end_src

**** colorcolumn

I prefer to never have text auto-wrap except in prose formats (non-code).

This command colors the 80th column slightly differently so that I can avoid
going over 80 characters, but also allows me to go over when I feel like it
is peferable.

#+begin_src vimrc
set colorcolumn=80
#+end_src

**** Set j,k to move up and down visual lines

This makes =j,k= move up and down display lines instead of moving by logical
lines (i.e. defined by ='\n'=) in normal and visual modes.  In visual *line*
mode still selects logical lines but I prefer to have the cursor always move
the same way.

#+begin_src vimrc
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk
#+end_src

** MISC

Keep the cursor 5 lines away from the top of the window.  Normally the window
doesn't start scrolling until the cursor reaches the very top or the very bottom
but with this, the text will start scrolling when the cursor gets within 5
lines of the top of the window.  Once you have it, you can't live with out it!

#+begin_src vimrc
set scrolloff=5
#+end_src

#+begin_src vimrc
syntax on
set hlsearch
set number
set showcmd " Display incomplete commands at the right
set backspace=indent,eol,start " Usual backspace behavior
set encoding=utf-8
#+end_src

** Show search hit count and index

I used to use the plugin
[[https://github.com/google/vim-searchindex][vim-searchindex]] for this but
this does what I want which is to show the =[i/N]= where =i= is the index of
the match that I'm on and =N= is the total number of matches.

#+begin_src vimrc
set shortmess-=S
#+end_src

** Leader key

#+begin_src vimrc
let mapleader = ' '
#+end_src

** Allow hidden buffers

Suggested by [[https://vi.stackexchange.com/questions/3364/open-filename-under-cursor-like-gf-but-in-a-new-tab-or-split][this vi.stackexchange post]] when looking for how to make =gf= open files in a new tab.

#+begin_src vimrc
set hidden
#+end_src

* Additional
** Color

This setting puts vim in 256 color mode.  Normally Vim looks at the value of
the =TERM= environment variable.  This setting ensures that Vim is in 256
color mode regardless of =TERM= which could be a bad idea if I were ever to
encounter a terminal that can't do but that has never happened, the only
thing that has happened is a badly set =TERM= variable.

#+begin_src vimrc
set t_Co=256 " Apparently this has to be set before setting the color scheme
#+end_src

In order to experiment with not using color in my shell and editors, I have
two environment variables which I set in my shell startup file
=__editor_grayscale= and =__shell_grayscale=.  With the =true-monochrome=
colorscheme, the color of the =colorcolumn= is red, so in that case, I
explicitly set its color.

#+begin_src vimrc :tangle no
if $__editor_grayscale == ""
    colorscheme molokai " Requires https://github.com/tomasr/molokai
    packadd powerline-plugin
else
    colorscheme true-monochrome
    highlight ColorColumn ctermbg=236
endif
#+end_src

#+begin_src vimrc :tangle vimrc
colorscheme molokai " Requires https://github.com/tomasr/molokai
packadd powerline-plugin
#+end_src

** Plugins
*** Markdown nested folding

Plugin : https://github.com/masukomi/vim-markdown-folding

#+begin_src vimrc
autocmd FileType markdown setlocal foldexpr=NestedMarkdownFolds()
#+end_src

*** Org

Plugins :
- https://github.com/jceb/vim-orgmode
- https://github.com/tpope/vim-speeddating (not the thing where you go to meet
  people, but a thing to work with dates really fast)

Org todo keywords
#+begin_src vimrc
let g:org_todo_keywords=['TODO', 'GTD-IN', 'GTD-ACTION', 'GTD-PROJECT', 'GTD-NEXT-ACTION', 'GTD-WAITING', 'GTD-SOMEDAY-MAYBE', 'FEEDBACK', 'VERIFY', '|', 'DONE', 'GTD-DONE', 'GTD-REFERENCE', 'GTD-DELEGATED']
#+end_src

Path to elisp backend
#+begin_src vimrc
let g:org_export_emacs="/usr/bin/emacs"
#+end_src

*** CtrlP

[[https://github.com/ctrlpvim/ctrlp.vim][CtrlP]] is a fuzzy finder for
opening files in Vim that opens up a buffer where you can type and it fuzzy
finds files.  The key to go into this buffer is =C-p=.  The following changes
the keybindings that are active inside the fuzzy finding buffer.

- I'm very used to using =C-n=, =C-p= to go up and down in popup menus and I
  don't feel like the history is very useful here.
- I always use tabs so I made =CR= the binding for opening in new tab. Again,
  I have to take =CR= out of the original binding.

#+begin_src vimrc
let g:ctrlp_prompt_mappings = {
            \ 'PrtSelectMove("k")': ['<C-p>'],
            \ 'PrtSelectMove("j")': ['<C-n>'],
            \ 'PrtHistory(-1)':     ['<down>'],
            \ 'PrtHistory(1)':      ['<up>'],
            \ 'AcceptSelection("t")': ['<CR>'],
            \ 'AcceptSelection("e")': [''],
            \ }
#+end_src

Note, since the original mapping for =C-p= is ='PrtHistory(1)'=, it seems
that I have to redefine the mapping for that history command as well.  Same
for =C-n= and ='PrtHistory(-1)'=.

Also, in the quickfix buffer, I use =C-p,C-n= to move up and down which would
trigger this plugin.  So I remap the key to =C-f=.  Since I only use =C-u=,
=C-d= to move up and down by chunks, I never use =C-f= and the 'f' evokes
finding.

#+begin_src vimrc
let g:ctrlp_map = '<C-f>'
#+end_src


*** Blamer

Plugin: https://github.com/APZelos/blamer.nvim

#+begin_src vimrc
let g:blamer_enabled=0
let g:blamer_show_in_insert_modes=0
#+end_src

Can be toggled on and off with =:BlamerToggle=.

It kind of causes weird things in the terminal vim so I'm going to leave it
off for now.

** Status line
*** Always show status line

2 means always

#+begin_src vimrc
set laststatus=2
#+end_src

*** New Powerline
**** Install instructions

These are the official instructions but this is not what I do.

https://powerline.readthedocs.io/en/latest/installation/osx.html#python-package

**** Using powerline

I use powerline with vim8's native plugin handling.

I put a link pointing to =$repo/powerline/bindings/vim= inside the
=~/.vim/pack/*/start=.

Make sure =laststatus=2= makes it always displayed.

**** Important note about macos

Adding powerline made vim hang and fail to start on my mac.  I figured out that
changing to a version of vim that has python3 support fixed my problem.

I did
#+begin_src shell
brew install --cask macvim
#+end_src
and made sure that this version of vim is the one being used.

*** Old powerline

Just added the submodule https//github.com/lokaltog/vim-powerline.  No need
to do anything else than make sure the =laststatus= is set to 2 (always).

Edit: I removed it but I am leaving this section here.  The new powerline made
my vim not start until I replaced it with macvim installed from homebrew.

The lokaltog one however doesn't need anything like that.

As far as I know, the problem only happens on mac and on the various linux
computers I have tried, the new powerline has not been an issue.

** Keys

*** Leaving insert mode

#+begin_src vimrc
inoremap jk <ESC>
#+end_src

**** Cursor position after leaving insert mode

99.99% of the time, I ended up pressing =l= after pressing =<ESC>= to leave
insert mode.

[[https://vim.fandom.com/wiki/Prevent_escape_from_moving_the_cursor_one_character_to_the_left#Programmatic_Alternative][This Vim Fandom answer]]
gives the solution used below and also tells you that if you want this this
behavior, then you dont care about consistency.  Hey Vim Fandom, you know
what's very consistent?  The fact that I always press =l= after leaving
insert mode!

#+begin_src vimrc
let CursorColumnI = 0 "the cursor column position in INSERT
autocmd InsertEnter * let CursorColumnI = col('.')
autocmd CursorMovedI * let CursorColumnI = col('.')
autocmd InsertLeave * if col('.') != CursorColumnI | call cursor(0, col('.')+1) | endif
#+end_src

Because of the nature of 'ESC' and the fact that terminals implement things
like function keys using =<ESC>[15~=, Vim waits a little while after <ESC>
has been received to see if something like =[15~= follows.

[[https://superuser.com/questions/1579208/delay-after-hitting-escape]]
[[https://vi.stackexchange.com/questions/16148/slow-vim-escape-from-insert-mode]]

This delay can be completely eliminated by telling vim that you will never
use such keys.  In that case, =ESC= will always mean that the user pressed
that key on the keyboard and there is no need for the delay.

#+begin_src vimrc :tangle no
set noesckeys
#+end_src

However I noticed that the arrow keys are implemented as an escape sequence.
Although I never use them, sometimes, I do them by mistake and the behavior
with =set noesckeys= is much more annoying than my =:echoerr "your mind is
weak"= things.

Instead, we can set =ttimeoutlen= to a very small value like 50ms and this is
short enough that we cannot notice it, but longer than the time between
successive keycodes sent by the terminal to communicate an arrow key.

#+begin_src vimrc
set timeoutlen=500 ttimeoutlen=50
#+end_src

Note however that other programs like TMUX also do this.  So if I have Vim open
in a TMUX pane, then when I press =ESC=, TMUX waits for the rest of the escape
sequence if there is one, then forwards an =ESC= to Vim.  Vim then waits for the
rest of an escape sequence, then leaves insert mode.  The point is that this
delay value is not the only one in play.


*** Cursor position after paste

Normally, the cursor ends on the last char of the pasted text but most of the
time, you want it after the pasted text.  For example, =P= to paste before
the cursor then =D= to delete till end of line.

#+begin_src vimrc
nnoremap p pl
nnoremap P Pl
#+end_src

This has a drawback which is that if the end of the pasted text is at the end of
the line, pressing =l= sends a bell to the terminal.  I turn off the bell in all
the terminal emulators I use so it doesn't affect me.

*** Scrolling

Up down move the cursor in one direction and scrolls the view in the other.
This has the effect that the cursor stays in the same place on the screen
which is a good behavior for scrolling.

#+begin_src vimrc
nnoremap <Up> <C-y>k
nnoremap <Down> <C-e>j
#+end_src

Sometimes I want to rest my chin in my left hand with my right hand on the mouse
as I peruse text and it's nice to be able to use the scroll wheel for that.

*** Make arrows print quotes from The Shadow (1994) with Alec Baldwin

#+begin_src vimrc
nnoremap <Left> <ESC>:echoerr "Your mind is weak."<CR>
nnoremap <Right> <ESC>:echoerr "Your mind is weak."<CR>

inoremap <Up> <C-O>:echoerr "Join me or die"<CR>
inoremap <Down> <C-O>:echoerr "The clouded mind sees nothing"<CR>
inoremap <Left> <C-O>:echoerr "Your mind is weak."<CR>
inoremap <Right> <C-O>:echoerr "The clouded mind sees nothing"<CR>
#+end_src

*** Shortcuts to navigate quickfix

#+begin_src vimrc
nnoremap <leader>cn :cnext<CR>
nnoremap <leader>cp :cprev<CR>
#+end_src

*** Shell keys for moving to beginning and end of line

My shell uses Emacs keybindings, most notably =C-a= and =C-e= to move to the
beginning and end of the line.  Plus the normal mode Vim bindings are less
convenient to type since I use CapsLock as a CTRL key.

#+begin_src vimrc
inoremap <C-a> <C-o>^
inoremap <C-e> <C-o>$
#+end_src

*** Preventing accidental number increments and decrements

Since my TMUX prefix key is =C-a= in I have
#+begin_src tmux
bind C-a send-keys C-a
#+end_src
in my =~/.tmux.conf= so that I can still send a =C-a= to an application by
pressing =C-a= twice.

Occasionally, I hesitate between the =C-a= and the tmux key binding I want to
use:  For example to enter copy-mode =C-a <hesitation> Enter=.  Occasionally
I will do =C-a <hesitation> C-a Enter= either because of muscle memory or
because I'm not sure if I cancelled the first =C-a=.

This leads to doing =C-a= twice which sends =C-a= to the application.  If
it's a shell no big deal, it sends my cursor to the start of the line and in
most other cases it either does nothing or something that I can easily notice.

But in Vim, in normal mode, =C-a= increments the number under the cursor
which is both really easy to miss and can have disastrous consequences.

#+begin_src vimrc
nnoremap <C-a> ^
nnoremap <C-x> <Nop>
#+end_src

Some of my Emacs reflexes make me use =C-x= in vim which decreases the next
number.  So I also disable =C-x=

*** Tmux style pane functions

#+begin_src vimrc
nnoremap <C-w>/ :vsplit<CR><C-w>l
nnoremap <C-w>- :split<CR><C-w>j
inoremap <C-w>/ <C-o>:vsplit<CR><C-o><C-w>l
inoremap <C-w>- <C-o>:split<CR><C-o><C-w>j
#+end_src

I never use =C-w= in insert mode to delete backwards one word and I'd rather
have it do the same thing that it does :vsplitl
#+begin_src vimrc
inoremap <C-w>h <C-o><C-w>h
inoremap <C-w>j <C-o><C-w>j
inoremap <C-w>k <C-o><C-w>k
inoremap <C-w>l <C-o><C-w>l
#+end_src

*** French language keyboard

The first thing I do when I open a file (therefore before I notice that
I'm in the CMS keyboard) is to search for something to position myself where I
want to go.

This leads to me pressing 'é' which does nothing but then when I try to enter
what I want to search for, I end up making a bunch of modifications to the file.

When I open a file, it's easy to undo everything but when I'm coming back to an
already opened file, then it's a bit more annoying.

#+begin_src vimrc
nnoremap é /
nnoremap É ?
#+end_src

In any case, I only use Vim in EN_US keyboard so I only need to remap the keys
for which it is annoying if I use the CMS keyboard ones without noticing.

*** =gf= opens in new tab

Suggested by [[https://vi.stackexchange.com/questions/3364/open-filename-under-cursor-like-gf-but-in-a-new-tab-or-split][this vi.stackexchange post]]

#+begin_src vimrc
nnoremap gf <C-w>gf
vnoremap gf <C-w>gf
#+end_src

something nice about this is that it doesn't require the file to be saved.

We can also do =set hidden= which allows having hidden buffers with unsaved
changes but I work with tabs anyway.

** Break the habit of pressing =x= multiple times
#+begin_src vimrc
nnoremap <silent> xx :echoerr 'Pressing "x" more than once consecutively is a sign of weakness'<CR>
#+end_src

** Display % as . in Fortran

Fortran uses =object%attribute= to get a field of a struct (in Fortran they
don't call it a struct, I think they call it a type).

I made this as a joke back when I first started programming in Fortran.  Obviously
the real solution is to get used to the language.

I'm tangling it commented so I can uncomment it quickly if I want to show
someone this sillyness.

#+begin_src vimrc
" Funny thing to show '%' as '.' in Fortran files
" autocmd FileType fortran set conceallevel=2
" autocmd FileType fortran call matchadd('Conceal', '%', 10, -1, {'conceal': '.'})
#+end_src

** YouCompleteMe

Code completion engine for Vim.

#+begin_src vimrc
" Technically version > 8.1.2269 but I only encounter either vim 8.0 or vim 9+
" so this is easier
if version >= 900
    " Silent makes it not complain if the package doesn't exits in
    " .vim/pack/*/opt/
    silent! packadd YouCompleteMe
    nnoremap gd :YcmCompleter GoToDefinition<CR>
endif
#+end_src

Disable confirmation of loading =.ycm_extra_conf.py=.  This could run someone
else's code if I were to work on a project that came with a
=.ycm_extra_conf.py=.  Therefore it is up to me to be careful with that.

#+begin_src vimrc
" Make sure to always check for a `.ycm_extra_conf.py` in new projects
let g:ycm_confirm_extra_conf = 0
#+end_src

** Command to justify text

This loads a visual mode command =_j= that will justify a paragraph of text.

The usefulness of this is somewhat questionnable, but it's fun to have I
guess.

Note that the format the format option 't' (=formatoptions+=t=) may make a
difference.  I read somewhere that it was needed but I'm not sure in what
cases.  I don't want to erroeneously think that it is needed so I'm leaving
it in commented.

#+begin_src vimrc
runtime macros/justify.vim
" set formatoptions+=t
#+end_src

** Unhighlight searches

For 10 years, I've been doing =/asdf<CR>= to unhighlight searches.

This stops now! I'll try these few options and possibly just keep one when I
find which one I like best.

#+begin_src vimrc
nnoremap <leader>c :noh<CR>
nnoremap <ESC><ESC> :noh<CR>
nnoremap <C-l> :noh<CR><C-l>
#+end_src

** Switch tab settings
Defines two functions to set groups of indentation related settings.  Note that
vim functions are weird: it seems that I cannot access the value of an argument
in a =set= command.  Instead, I have to do =let &<option>=a:<argument>=
according  to [[https://vi.stackexchange.com/a/11534/7936][this stack overflow post]] and that's just one of the reasons why I
like Emacs LISP better than Vimscript.

These functions are useful for example when browsing code that is indented
using tabs 

=TabMode= displays tabs as =a:nb= spaces with and leading spaces are marked using
=listchars= disables =expandtab=.

#+begin_src vimrc 
function! TabMode(nb)
    setlocal listchars=tab:\ \ ,lead:·,trail:·,precedes:←,extends:→
    let &tabstop=a:nb     " Display width of \t character
    let &shiftwidth=a:nb  " Indents will have a width of 4.
    let &softtabstop=a:nb " Sets the number of columns for a TAB.
    set noexpandtab       " Don't expand tabs to spaces
endfunction
#+end_src

=SpaceMode= sets my preferred settings for indentation: tabs are expanded and
leading tabs are displayed using =listchars=.

#+begin_src vimrc 
function! SpaceMode(nb)
    setlocal listchars=tab:»~,extends:›,precedes:‹,nbsp:·,trail:·
    let &tabstop=a:nb       " Display width of \t character
    let &shiftwidth=a:nb    " Indents will have a width of 4.
    let &softtabstop=a:nb   " Sets the number of columns for a TAB.
    set expandtab           " Expand TABs to spaces.
endfunction
#+end_src

And we add two shortcut commands to call these functions more easily.  I chose
the argument 8 for =TabMode= because of the Linux style guide and 4 for
=SpaceMode= because that matches my default settings.

#+begin_src vimrc
command Tabs :call TabMode(8)
command Spaces :call SpaceMode(4)
#+end_src

** Doing =:w*= in insert mode

It doesn't happen super often but often enough.  Especially when I have
multiple tabs open.  Sometimes I want to do =:wqa= but sometimes I want to
simply do =:wq= repeatedly to close all the tabs and one of them will be in
insert mode.

#+begin_src vimrc
inoremap :w<CR> <ESC>:w<CR>
inoremap :wq<CR> <ESC>:wq<CR>
inoremap :wqa<CR> <ESC>:wqa<CR>
#+end_src

** Going to files

The normal mode =gf= and =gF= open the file under the cursor but only if it
exists.  This mapping is a way to create the file if it doesn't exist but
also to open it in a tab.

#+begin_src vimrc
nnoremap <Leader>gf :tabe <cfile><CR>
#+end_src

** Color cursor

Make the cursor change color and shape depending on the mode.  Green bar in
insert mode, red box in replace mode, yellow box in other modes.  Note that this
only works if the terminal emulator responds to these codes.

#+begin_src vimrc
let &t_SI = "\<Esc>]12;green\x7\<Esc>[6 q"
let &t_SR = "\<ESC>]12;red\x7"
let &t_EI = "\<Esc>]12;yellow\x7\<Esc>[2 q"
autocmd VimEnter * silent !echo -e "\033]12;blue\007"
autocmd VimLeave * silent !echo -ne "\033]112\007"

if version >= 900
    autocmd VimSuspend * silent !echo -ne "\033]112\007"
    autocmd VimResume * silent !echo -ne "\033]12;blue\007"
endif
#+end_src

Note that the =-n= was taken off the =echo= command for =VimEnter= because
otherwise it somehow messed with some other escape codes.

Described in =runtime/doc/term.txt=, these are codes to send to the terminal
when entering insert mode, entering replace mode, and exiting those two
modes.

- =t_SI= gets output when entering insert mode,
- =t_SR= gets output when entering replace mode
- =t_EI= gets output when leaving insert or replace mode

The autocommands set the cursor back to default when leaving vim.  =VimLeave=
for when we quit, =VimSuspend= when doing =C-z= to put Vim in the background,
and =VimResume= when putting Vim back to the foreground.  Note that when
foregrounding Vim, I set the cursor to a yellow box.

The =silent !echo ...= turns the cursor blue during startup.  Files that have a
mark set in =~/.viminfo= start with a yellow cursor and files that don't start
with a blue cursor.  So it's like when a file has a position saved in viminfo,
goint to that place outputs =t_EI=.

While browsing the [[https://emacs.stackexchange.com]], I found
[[https://emacs.stackexchange.com/questions/14929/how-do-i-set-cursor-colours-per-evil-state-in-the-non-gui-text-terminal/83102#83102][a question about cursor colors in the terminal]] where I discovered that it was
sometimes possible (depending on the terminal emulator) for terminal programs to
change the cursor color.  I made it work for Emacs as we can see in my answer on
that question.

For Vim, I found
- [[https://vim.fandom.com/wiki/Configuring_the_cursor]]
- [[https://www.linuxquestions.org/questions/programming-9/vim-can%27t-change-cursor-color-4175593194/]]
- =:help t_EI= (=:help terminal-options=) in Vim shows the available settings.

Later, trying spacemacs to figure out how it was doing some other thing, I
noticed that it changes the shape of the cursor to a bar in insert mode.
So I looked for how they do it and found this [[https://github.com/syl20bnr/spacemacs/issues/7112#issuecomment-389855491][issue on Spacemacs repo]]
which cites [[https://vt100.net/docs/vt510-rm/DECSCUSR][the VT100 documentation]].

Codes used here:

| Code            | Effect                                           |
|-----------------+--------------------------------------------------|
| =\033]12;_\007= | Set cursor color using the name of the color     |
| =\033[6 q=      | Make the cursor a vertical bar                   |
| =\033[2 q=      | Make the cursor a box                            |
| =\033[112\007=  | Set the cursor back to default (color and shape) |

Terminal emulators that respond to these codes:

| Terminal emulator | Works or not |
|-------------------+--------------|
| Konsole           | Yes          |
| Mate Terminal     | No           |
| Terminal.app      | Only in TMUX |
| iTerm.app         | Only in TMUX |
| VSCode shell      | Only in TMUX |
| Windows Terminal  | Yes          |
| Windows CMD       | Yes          |


** OSC52 copying

The plugin [[https://github.com/ojroques/vim-oscyank][vim-oscyank]] adds some
functions that send text to the system clipboard assuming that the terminal
emulator supports it.

This works over SSH because the control sequence requesting to put a string
in the system clipboard is read by the local terminal emulator.

Since TMUX is between the running program and the terminal emulator, it has
power over this.  The [[https://github.com/tmux/tmux/wiki/Clipboard][set-clipboard]] option decides
whether or not TMUX will forward the OSC52 sequence it receives from the
program to the terminal emulator.

#+begin_src conf :tangle no
set -g set-clipboard on
#+end_src

In nested TMUX sessions, if all the TMUX's have =set-clipboard= set to =on=,
a program's OSC52 sequence will make its way to the terminal emulator.

When TMUX gets an OSC52, (assuming =set-clipboard= has the value =on= or
=external=), then it will set its own paste buffer.

See =man tmux= and look for =set-clipboard= for a short description of the
behavior.

This function is meant to be used as described in
[[https://vimdoc.sourceforge.net/htmldoc/map.html#:map-operator][mapping an operator]] section of the vim help.

#+begin_src vimrc
function! MyOSCYankAndNormalYank(type, ...)
    if a:0  " Invoked from Visual mode, use '< and '> marks.
        silent exe "normal! `<" . a:type . "`>y"
    elseif a:type == 'line'
        silent exe "normal! '[V']y"
    elseif a:type == 'block'
        silent exe "normal! `[\<C-V>`]y"
    else
        silent exe "normal! `[v`]y"
    endif
    call OSCYank(getreg("+"))
endfunction
#+end_src

The bindings below call this function.  Note that the underscore makes makes
the operator operate on the current line.

#+begin_src vimrc
nmap <silent> y :set opfunc=MyOSCYankAndNormalYank<CR>g@
nmap <silent> yy y_
vmap <silent> y :<C-U>call MyOSCYankAndNormalYank(visualmode(), 1)<CR>
#+end_src

- [[https://stackoverflow.com/a/38720453/5795941][vimscript: How do I save and restore a register]]
- [[https://vi.stackexchange.com/a/19746/7936][Why is the underscore command useful]]

** Super list chars

For =~/.ssh/authorized_keys=, make listchars pop very intensely.

Set =listchars= to basically everything including regular spaces because a
rogue space character coming from pasting and joining can be easy to miss.

To make the listchars pop even more, =SpecialKey= group is spaces and tabs
and the =NonText= group is the newline character and maybe others.

#+begin_src vimrc
function! SuperList()
    colorscheme elflord
    setlocal listchars=tab:»~,extends:›,precedes:‹,nbsp:·,trail:·,space:\ ,eol:$
    hi SpecialKey ctermfg=cyan ctermbg=blue
    hi NonText ctermfg=cyan
    hi Comment ctermfg=darkgrey
endfunction
autocmd BufReadPost authorized_keys :call SuperList()
#+end_src

* Language specific commands
** Default filetype
I would have liked it if doing =vim file_without_extension= would set the
filetype to =sh= only if no filetype was detected so that my =<Leader>sb= and
=<Leader>ssb= set in =ftplugin/sh.vim= would be active.

I tried the following:
#+begin_src vimrc :tangle no
autocmd BufNewFile,BufRead * if (expand('%:t') !~ '\.') && (expand('%:t') !~ '[mM]akefile') && (getline(1) !~ '^#!*') | let b:is_bash=1 | let b:is_sh=0  | setfiletype sh | endif
#+end_src
but this would set the filetype to =sh= in situations where I didn't want it
to.  Makefiles are an example for which I added an exception but after trying
this out for a while, it became clear that it wasn't worth it.

The simple way to solve this is to just have this:
#+begin_src vimrc
nnoremap <buffer> <Leader>ssb ggi#!/usr/bin/env -S bash -o errexit -o nounset -o errtrace -o pipefail -O inherit_errexit -O nullglob -O extglob<CR><BS><CR><ESC>
nnoremap <buffer> <Leader>sb ggi#!/bin/bash<CR><BS><CR><ESC>
#+end_src
in my =vimrc= so that when no filetype is detected, these keys insert the
BASH shebangs.

If a different filetype is detected, then the keys set in the
=ftplugin/<X>.vim= will override these values.

Most of the time that I create an empty text file with no extension for which
I want to insert a shebang, it will be BASH.  In the rarer cases like a
Python file, then I can just write it by hand.

In both cases, after I have a shebang, I can do =:e= at which point the
filetype will be detected from the shebang.

** Go
Highlight space vs tab errors by requesting from the syntax file.
#+begin_src vimrc :tangle ftplugin/go.vim
let g:go_highlight_space_tab_error = 1
#+end_src
this setting is used in =share/vim*/syntax/go.vim= to decide whether
or not to highlight tab/space errors.

Set indentation stuff.  Most important is noexpandtab to get real tab
characters.
#+begin_src vimrc :tangle ftplugin/go.vim
setlocal tabstop=8 shiftwidth=8 softtabstop=0 noexpandtab
#+end_src

Set list chars.  No list char for tabs.  Vim 9+ has =lead= for leading
spaces.  For previous versions of Vim, we only have =space= which includes
spaces inside the line.

In any case, because the syntax highlighting shows the tab/space errors
well, we turn off the =list= option.
#+begin_src vimrc :tangle ftplugin/go.vim
setlocal nolist
if version >= 900
    setlocal listchars=tab:\ \ ,lead:·,trail:·,precedes:←,extends:→
else
    setlocal listchars=tab:\ \ ,space:·,trail:·,precedes:←,extends:→
endif
#+end_src

** Make

Same as Go, I didn't find a way to reuse the code so I'm just repeating here.

Like Go, no need to enable listchars since =syntax/make.vim= also has a thing
to highlight wrongly indented lines except no need to enable anything.

#+begin_src vimrc :tangle ftplugin/make.vim
setlocal tabstop=8 shiftwidth=8 softtabstop=0 noexpandtab
#+end_src

#+begin_src vimrc :tangle ftplugin/make.vim
setlocal nolist
if version >= 900
    setlocal listchars=tab:\ \ ,lead:·,trail:·,precedes:←,extends:→
else
    setlocal listchars=tab:\ \ ,space:·,trail:·,precedes:←,extends:→
endif
#+end_src

** Fortran

#+begin_src vimrc :tangle ftplugin/fortran.vim
nnoremap <buffer> <Leader>ife ouse, intrinsic :: iso_fortran_env<ESC>==
nnoremap <buffer> <Leader>icb ouse, intrinsic :: iso_c_binding<ESC>==
nnoremap <buffer> <Leader>ino oimplicit none<ESC>==
#+end_src

Set free form for Fortran syntax highlighting.

#+begin_src vimrc :tangle ftplugin/fortran.vim
let fortran_free_source=1
#+end_src

Someone also had this in his config with the Fortran free from thing.

#+begin_src vimrc :tangle ftplugin/fortran.vim
let fortran_more_precise=1
#+end_src


** Python

#+begin_src vimrc :tangle ftplugin/python.vim
nnoremap <buffer> <Leader>sb ggi#!/usr/bin/env python3<CR><CR><ESC>
#+end_src

** BASH

Add shebang and super-shebang.

Also =sso= to add the same options as the super
shebang but as =set=/=shopt= commands:
#+begin_src bash :tangle no
set -o errexit             # Exit when any command fails or any error happens
set -o nounset             # Dereferencing unbound variables is an error
set -o errtrace            # Trap on ERR is inherited by functions and subshells
set -o pipefail            # A pipe fails if any command of the pipe fails
shopt -s inherit_errexit   # Subshells inherit the errexit setting
shopt -s nullglob          # A glob that matches nothing expands to nothing
shopt -s extglob           # Activate extra globbing options
#+end_src
this is useful to activate the options somewhere else than at the very start
of the script if for example we need to source a script that would trigger
=errexit= because of things like dereferencing unbound variables.

In =man bash= subshells =(...)= and command substitution =$(...)= are two
different things but in the above, I use "subshell" to mean both.

All the non-glob options are to make BASH more like languages like Python
where if anything bad happens, an exception and the program stops right then
and there.

#+begin_src vimrc :tangle ftplugin/sh.vim
nnoremap <buffer> <Leader>ssb ggi#!/usr/bin/env -S bash -o errexit -o nounset -o errtrace -o pipefail -O inherit_errexit -O nullglob -O extglob<CR><BS><CR><ESC>
nnoremap <buffer> <Leader>sb ggi#!/usr/bin/env bash<CR><BS><CR><ESC>
nnoremap <buffer> <Leader>sso iset -o errexit<CR>set -o nounset<CR>set -o errtrace<CR>set -o pipefail<CR>shopt -s inherit_errexit<CR>shopt -s nullglob<CR>shopt -s extglob<CR><CR><ESC>
#+end_src

*** About different types of highlightings for shell scripts

I've long wondered why =$(= and =)= were highlighted as errors in some shell
scritps that were missing a =#!/bin/bash= but not all the time.

I've found out and here is a good place to record the knowledge.

When any bash, sh, ksh script is opened by Vim, the file
=share/vim/vim*/syntax/sh.vim= is executed.  It defines syntax highlighting
rules for shell scripts including things to highlight as errors.

Because shells are not all the same, this starts by attempting to determine
which shell the script is for.  The rest of the file defines the syntax with
some =if= statements based on the results of trying to guess the target shell
of the script.

To determine the shell, it looks at the first line for a =#!=.  If there
isn't one, it assumes the script will be run by =/bin/sh=.

If there is no =#!= or it is =#!/bin/sh=, then the syntax file attemps to
guess what shell =/bin/sh= is.  On many systems nowadays, =/bin/sh= is a link
to either =bash= or =dash=.  By resolving the link, =sh.vim= can know the
shell.

On MacOS, the platform of choice for my personal computers, =sh= is not a
link to anything so the final result is that old-school Bourne Shell
highlighting is used.

**** Solution and why I don't use it

We *could* fix this by putting =let g:is_posix= in this file
(=ftplugin/sh.vim=).

I think that it is an error to omit a =#!= and I want to notice when I forget
to do it.  Threrefore, I use =$(= and its closing =)= being highlighted in
purple as a reminder that I should have one.

** CMake

#+begin_src vimrc :tangle ftplugin/cmake.vim
nnoremap <buffer> <Leader>sb ggicmake_minimum_required(VERSION 3.20)<CR><CR>project(X C Fortran)<CR><CR><ESC>
nnoremap <buffer> <Leader>ch oinclude(CTest)<CR>add_custom_target(check COMMAND ${CMAKE_CTEST_COMMAND})<CR><CR><ESC>
#+end_src
** Org

*** Surround visual selection with =#+begin_src=, =#+end_src= tags
[[https://vimhelp.org/visual.txt.html][:h visual]]

Using =`>= after leaving visual mode moves to the end of the visual selection
and =`<= moves to the start.

#+begin_src vimrc :tangle ftplugin/org.vim
vnoremap <C-s> <ESC>`>a<CR>#+end_src<ESC>`<i#+begin_src <CR><ESC>kA
#+end_src

So this is just moving to the end, insert some text, move to the start,
insert some text and we end by putting ourself in insert mode at the end of
the =#+begin_src= line to write the language.

I tried to make the key be =<C-c>,= like in Emacs but it doesn't let me
rebind =C-c=.

*** Failed attempt

This [[https://vi.stackexchange.com/a/15479/7936][Stack Overflow Answer]]
doen't work when the selection is multiple lines.

#+begin_src vimrc :tangle no
vnoremap <C-s> :s/\%V.*\%V/#+begin_src\r&\r#+end_src/<CR>
#+end_src


** Markdown

Built into vim, markdown can have syntax highlighting for the languages we
request it for which I only found out by coïncidence while browsing Tim Pope's
repos on github and saw [[https://github.com/tpope/vim-markdown?tab=readme-ov-file#vim-markdown-runtime-files][the readme for his fork of vim-markdown]].

#+begin_src vimrc :tangle ftplugin/markdown.vim
let g:markdown_fenced_languages = ['python', 'bash=sh', 'fortran', 'c', 'lisp', 'go', 'rust']
#+end_src

Use =Tab= and =S-Tab= to expand and collapse markdown folds.  It seems like
this could go in =ftplugin/markdown.vim=, I don't remember if I tried it.

#+begin_src vimrc
autocmd FileType markdown setlocal foldexpr=NestedMarkdownFolds()
autocmd FileType markdown nnoremap <S-Tab> zA
autocmd FileType markdown nnoremap <Tab> za
#+end_src


* Filetype associations

** Header

This section generates the file =filetype.vim=.

#+begin_src filetype
" This file is generated by org-tangle'ing vimconfig.org using the command
" 'emacs --batch -l org --eval "(setq org-src-preserve-indentation t)" vimconfig.org -f org-babel-tangle'
if exists("did_load_filetypes")
  finish
endif
augroup filetypedetect
#+end_src

** Non-standard fortran file extensions

These extensions are used in conjunction with =s.cc= or =s.compile=.  These
wrappers do something different with the files based on the extension.
However these are not know by standard programs.

#+begin_src filetype
    autocmd BufRead,BufNewFile *.ftn,*.ftn90,*.cdk,*.cdk90,*.inc,*.hf set filetype=fortran
#+end_src

** Fortran namelist files

#+begin_src filetype
    autocmd BufRead,BufNewFile *.nml set filetype=fortran
#+end_src

** HCRON files

Any file under =~/.hcron= or files ending with =.hcron=.

#+begin_src filetype
    autocmd BufRead,BufNewFile */.hcron/*,*.hcron set filetype=hcron
#+end_src

** '.dot' file from CMC

The =.dot= extension is used to indicate that the script in question is meant
to be sourced.  The extension is recognized by vim as 'dot graph'.  To
override this:

#+begin_src filetype
    autocmd BufRead,BufNewFile *.dot set filetype=sh
#+end_src

** CMC profile files

#+begin_src filetype
    autocmd BufRead,BufNewFile */.profile.d/*   set filetype=sh
#+end_src

** CMC maestro files

When we ask maestro open a listing, it will decompress the stored listing
into a file in some subdirectory of =/tmp/= name the file =masetro_something=
#+begin_src filetype
    autocmd BufRead,BufNewFile *.tsk,*.def,*/.suites/*/*.cfg,/tmp/phc001/*/maestro* set filetype=sh
#+end_src

** fc tempfiles in BASH

When using =fc= (fix command) or doing =C-x C-e= to edit a command, BASH
creates a temporary file, opens it with your editor and waits for it to quit.
It then runs the content of that file (like sourcing it).

The file is named as if created by the command =mktemp bash-fc.XXXXXX --tmpdir=.

Note that =C-x C-e= also creates a file named =bash-fc.XXXXXX=.

#+begin_src filetype
    autocmd BufRead,BufNewFile *bash-fc* set filetype=sh
#+end_src
** Alternative Git configuration files

#+begin_src filetype
    autocmd BufRead,BufNewFile *gitconfig* set filetype=gitconfig
#+end_src

** Alternative TMUX configuration files

#+begin_src filetype
    autocmd BufRead,BufNewFile *tmux.conf* set filetype=tmux
#+end_src

** Footer
#+begin_src filetype
augroup END
#+end_src



* Shell command to tangle

To tangle from the shell, use this command:
#+begin_src sh
emacs --batch -l org --eval "(setq org-src-preserve-indentation t)" FILE -f org-babel-tangle
#+end_src

Note where the =FILE= appears in the command.

It seems that it must appear before the =-f org-babel-tangle= argument.

The manual =man emacs= says this about =-f=, =-l=, =-e, --eval=:

#+begin_quote
The following options are Lisp-oriented (these options are processed in the
order encountered):
#+end_quote

Note the =(setq org-src-preserve-indentation t)= in the command.  For this to
apply when tangling this file from Emacs with =C-c C-v C-t=, the line
=-*- org-src-preserve-indentation: t -*-= sets the same variable to =t= for this
file only.  It must be the first line of the file otherwise it has no effect.


* Syntax files

** Generic

[[This stack over flow post][https://vi.stackexchange.com/a/47189/7936]]
about highlighting on top of listchars.  It turns out that using the latest
=sh.vim= file is better for catching bad heredocs so this is not necessary

#+begin_src vimrc :tangle no
match Error "\( \+\t\@1=\)\|\(\t\@1<= \+\)"
#+end_src

** Shell syntax

Looking at =/usr/share/vim/vim80/syntax/syntax.sh=, we see

#+begin_src vimrc :tangle no
ShFoldHereDoc syn region shHereDoc matchgroup=shHereDoc03 start="<<-\s*\z([^ \t0-9|>]\+\)"                     matchgroup=shHereDoc03 end="^\s*\z1\s*$"	contains=@shDblQuoteList
ShFoldHereDoc syn region shHereDoc matchgroup=shHereDoc04 start="<<-\s*'\z([^'0-9]\+\)'"                       matchgroup=shHereDoc04 end="^\s*\z1\s*$"
ShFoldHereDoc syn region shHereDoc matchgroup=shHereDoc05 start="<<\s*'\z([^'0-9]\+\)'"                        matchgroup=shHereDoc05 end="^\z1\s*$"
#+end_src

This handles every type of heredoc, the first one

This with the actual file containing =shHereDoc01= to =shHereDoc15= to handle
every type of heredoc.  In the ones shown here, =shHereDoc03= matches
#+begin_src shell
<<- DELIM
...
	DELIM
#+end_src
where we have the start defined by
- The string =<<-=
- Zero or more whitespace characters =\s*=
- An atom composed of only letters dashes and underscores: =\z([^ \t0-9|>]\+\)=
and the end defined by
- Beginning of line =^=
- Zero or more whitespace characters =\s*=
- The thing we matched with =\z=: =\z1=
- Zero or more whitespace characters =\s*=
- The end of the line

And the =shHereDoc05= does not allow whitespace between the start of the line
and the end marker because that one is started with =<<= rather than =<<-=

This is all good but it's incorrect.

- For the end part of the =<<-= type heredocs, there can only be tabs between
  the beginning of the line and the marker.
- For the end part of all the types of heredoc, there can't be spaces after the
  marker.

So the following are incorrect (underscores represent spaces)

#+begin_src shell
cat <<- DELIM
DELIM____

cat <<-DELIM
____DELIM
#+end_src

This was fixed in vim91 so my =after/syntax/sh.vim= is a copy of that file.

